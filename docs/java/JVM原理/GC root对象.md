# GC root对象

JVM在进行垃圾回收时，需要找到垃圾对象，也就是没有被引用过的对象，但是寻找垃圾对象是比较耗时的，所以反过来，先找非垃圾对象，此时就需要从某些“根”开始寻找，根据根的引用路径找到正常对象，而这些根有一个共同特征，就是它只会引用别的对象，而不会被其他对象所引用。

GC Root的对象有：

（1）虚拟机栈（栈帧中的本地变量表）中引用的对象。

（2）方法区中的类静态属性引用的对象。

（3）方法区中常量引用的对象。

（4）本地方法栈中JNI(即一般说的Native方法)引用的对象。

（5）正在运行的线程。

可达性分析算法中的不可达对象并不是立即死亡的，对象拥有一次自我拯救的机会。对象被系统宣告死亡至少要经历两次标记过程：第一次是经过可达性分析发现没有与GC Roots相连接的引用链，第二次是由虚拟机自动建立的Finalizer队列中判断是否需要执行finalize()方法。

当对象变成GC Root不可达时，GC会判断该对象是否覆盖了finalize方法，若未覆盖，则将其直接收回。否则，若对象未执行过finalize方法，则将其放入F-Queue队列，由低优先级线程执行该队列中对象的finalize()方法。执行finalize方法完毕后，GC会再次判断判断对象是否可达，若不可达，则进行回收，否则对象复活。

每个对象只能触发一次finalize()方法。

由于finalize()方法运行代价高昂，不确定性大，无法保证各个对象的调用顺序，不推荐使用。
