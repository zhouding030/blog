# JVM内存模型

JVM（Java虚拟机）的内存模型主要有以下三个部分组成：类加载子系统、运行时数据区、执行引擎。

## 类加载子系统
待完善。。。


## 运行时数据区

运行时数据区又分为以下几个部分：程序计数器、虚拟机栈、本地方法栈、堆和方法区。

**1.程序计数器：**
这是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。如果线程正在执行的是Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址。如果正在执行的是本地（Native）方法，这个计数器值则为空（Undefined）。此内存区域是唯一一个在《Java虚拟机规范》中没有规定任何OutOfMemoryError情况的区域。

**2.虚拟机栈：**
描述的是Java方法执行的线程内存模型。每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信息。

**3.本地方法栈：**
与虚拟机栈所发挥的作用非常相似，不过虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。

**4.堆：**
堆内存分为新生代和老年代。新生代中又分为Eden区、From区和To区。新生代的内存空间主要用于实例化对象，当Eden区内存足够时，对象会存储在Eden区，内存不够时则会在新生代中寻找其他可以存放的区进行存储，如果找不到合适的空间则会报出OOM异常。老年代则用于存储生命周期长久的实例对象。

**5.方法区：**
与Java堆一样，是各个线程共享的内存区域。多个线程同时加载同一个类时，只有一个线程能加载该类，其他线程只能等待该线程加载完毕，然后直接使用该类。方法区在JVM启动的时候被创建，其实际的物理内存空间中和Java堆区一样都可以是不连续的。方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展

## 执行引擎
待完善

